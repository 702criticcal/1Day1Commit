CS(Computer Science)
=====================
자료구조 (Data structure)
------------------
컴퓨터 과학에서 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미합니다. 더 정확히 말해, 자료 구조는 **데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령**을 의미합니다.

### 1. 해시 테이블 (Hash table)
##### 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조다.
*ADT(Abstract Data Type) : 컴퓨터 과학에서 자료들과 그 자료들에 대한 연산들을 명기한 것. ADT는 구현 방법을 명시하고 있지 않다는 점에서 자료 구조와 다르다.*
* 분할 상환 분석에 따른 **시간 복잡도가 O(1)**. 덕분에 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다!

##### 해시 함수 (Hash Function)
임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수.
* 정수형 해싱 기법 - 모듈로 연산을 이용한 나눗셈 방식

##### 로드 팩터 (Load Factor)
해시 테이블에 저장된 **데이터 개수를 버킷의 개수로 나눈 것**.
로드 팩터 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다. 또한, 해시 함수의 효율성 측정에도 사용된다. 로드 팩터가 증가할 수록 해시 테이블의 성능은 점점 감소하게 된다.

#### 개별 체이닝 (Separate Chaining)
해시 테이블의 기본 방식이기도 한 개별 체이닝은 충돌 발생 시 연결 리스트로 연결하는 방식.
1. 키의 해시 값을 계산한다.
2. 해시 값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 연결한다.

대부분의 시간 복잡도는 O(1). 최악의 경우, 즉 모든 해시 충돌이 발생했다고 가정할 경우에는 O(n).

#### 오픈 어드레싱 (Open addressing)
충돌 발생 시 탐사를 통해 빈 공간을 찾는 방식. 저장 공간의 제약이 없는 체이닝 방식과 달리 전체 슬롯의 개수 이상은 저장할 수 없다!
1. 키의 해시 값을 계산한다.
2. 해시 값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 연결한다.

충돌이 일어나면 테이블 공간 내에서 탐사를 통해 빈 공간을 찾아 해결하기 때문에 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.
버킷 사이즈보다 큰 경우에는 데이터를 삽입할 수 없다. 따라서 일정 이상 채워지면, 즉 기준이 되는 로드 팩터 비율을 넘어서게 되면, 그로스 팩터의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱 작업이 일어난다.

**파이썬의 딕셔너리**는 **오픈 어드레싱 방식으로 구현된 해시 테이블로 구현**되어 있다.
* 연결 리스트를 만들기 위해서는 추가 메모리 할당이 필요하고, 추가 메모리 할당은 상대적으로 느린 작업이기 때문에 택하지 않았다 by. 앤드류 커클링
* 슬롯의 80% 이상이 차게 되면 급격한 성능 저하가 일어나는 것이 오픈 어드레싱의 특징이므로, 파이썬은 로드 팩터를 작게 잡아 성능 저하 문제를 해결했다. (파이썬의 로드 팩터 = 0.66)
<hr/>

### 2. 우선순위 큐 (Priority Queue)
##### 어떠한 특정 조건에 따라 우선순위가 가장 높은 요소가 추출되는 자료형이다.
* 정렬 알고리즘을 사용하면 우선순위 큐를 만들 수 있다.
    * n 개의 요소를 정렬하는 데 S(n)의 시간이 든다고 할 때, 새 요소를 삽입하거나 요소를 삭제하는 데는 O(S(n))의 시간이 걸린다. 반면 내림차순으로 정렬했을 때 최댓값을 가져오는 것은 맨 앞의 값을 가져오기만 하면 되므로 O(1)로 가능하다. 대개 정렬에는 O(nlogn)이 필요하기 때문에 O(S(n))은 O(nlogn) 정도가 든다.
    * 그러나 실제로는 이처럼 단순 정렬보다는 힙 정렬 등의 좀 더 효율적인 방법을 사용한다!
* 최단 경로를 탐색하는 다익스트라 알고리즘 등에 활용된다!

##### PriorityQueue VS heapq
* 파이썬에서 우선순위 큐는 queue 모듈의 PriorityQueue 클래스를 이용해 사용할 수 있다. 하지만 PriorityQueue조차 내부적으로는 힙을 사용한 heapq를 사용하도록 구현되어 있다.
* 둘의 차이점은 PriorityQueue 클래스는 **스레드 세이프 클래스**이지만, heapq 모듈은 스레드 세이프를 보장하지 않는다!
* PriorityQueue 클래스가 스레드 세이프를 보장하기 때문에 내부적으로 락킹을 제공하여 락킹 오버헤드가 발생해 성능에 영향을 미친다.
    * 스레드 세이프 : 멀티 스레드에도 안전한 프로그래밍 개념. 스레드 세이프를 하지 않은 경우 1번 스레드 값이 2번 스레드에서 변경될 수 있어 문제가 발생할 수 있다.
* **결론 : 멀티 스레드를 구현하는 것이 아니라면 PriorityQueue 클래스를 사용할 필요가 없다.**

<hr/>

### 3. 힙 (Heap)
##### 최소 힙에서는 부모가 항상 자식보다 작거나 같다는 힙의 특성을 만족하는 거의 완전한 트리인 특수한 트리 기반의 비선형 자료구조
* 파이썬에서는 최소 힙만 구현되어 있다.
    * 최소 힙은 부모가 항상 자식보다 작기 때문에 루트가 결국 가장 작은 값을 갖게 되며, 우선순위 큐에서 가장 작은 값을 추출하는 것은 매번 힙의 루트를 가져오는 형태로 구현된다.
    * 우선순위 큐 ADT는 주로 힙으로 구현하고, 힙은 주로 배열로 구현한다. -> 결국 우선순위 큐는 배열로 구현하는 셈이다!
* 자식 노드가 둘인 힙을 **이진 힙(Binary Heap)** 이라고 부르며 가장 많이 쓰인다.
* 완전 이진 트리 형태인 이진 힙은 배열에 빈틈없이 배치가 가능하며, 트리의 배열 표현의 경우 계산을 편하게 하기 위해 인덱스는 1부터 사용한다.

<hr/>