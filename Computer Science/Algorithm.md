CS(Computer Science)
=====================
알고리즘 (Algorithm)
------------------

### 1. 다이나믹 프로그래밍 (Dynamic Programming)
##### 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘
응용 수학자 리차드 벨만이 1953년에 고안한 알고리즘
* 적용 문제 : 최적 부분 구조를 갖고 있는 문제를 풀이할 수 있습니다. 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우의 문제
* 대부분의 재귀 알고리즘을 포함한 0-1 배낭 문제, 피보나치 수열, 다익스트라 알고리즘 문제의 해결이 가능합니다.
* 그리디 알고리즘과의 차이점 : 그리디 알고리즘은 **항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이**해 나가는 것이고, 다이나믹 프로그래밍은 **중복된 하위 문제들의 결과를 저장해뒀다가 풀이**해 나간다는 차이가 있습니다.

	* **'중복된'** 문제이지 않으면 다이나믹 프로그래밍으로 풀지 않습니다. 중복되지 않은 문제의 경우, 분할 정복 알고리즘으로 풀이합니다.

#### 1-1. 다이나믹 프로그래밍 방법론
1. **상향식 (Bottom-Up)** a.k.a. **Tabulation** : 더 작은 하위 문제부터 살펴본 다음, **작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나갑니다.** 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 합니다. 데이터를 테이블 형태로 만들면서 문제를 풀이한다고 하여 타뷸레이션 방식이라고 부릅니다.
```
def fib(n):
	dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n + 1):
    	dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```
2. **하향식 (Top-Down)** a.k.a. **Memoization** : 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어나갑니다. **기존 재귀 풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적인 방식**으로, 메모이제이션 방식이라고 부릅니다.
```
def fib(n):
	if n <= 1:
    	return 1
        
    if dp[n]:
    	return dp[n]
    dp[n] = fib(n - 1) + fib(n - 2)
    return dp[n]
```

<hr/>
### 2. 탐욕 알고리즘 (Greedy Algorithm)
