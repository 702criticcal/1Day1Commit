CS(Computer Science)
=====================
알고리즘 (Algorithm)
------------------

### 1. 다이나믹 프로그래밍 (Dynamic Programming)
##### 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘
응용 수학자 리차드 벨만이 1953년에 고안한 알고리즘
* 적용 문제 : 최적 부분 구조를 갖고 있는 문제를 풀이할 수 있다. 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우의 문제
* 대부분의 재귀 알고리즘을 포함한 0-1 배낭 문제, 피보나치 수열, 다익스트라 알고리즘 문제의 해결이 가능하다.
* 그리디 알고리즘과의 차이점 : 그리디 알고리즘은 **항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이**해 나가는 것이고, 다이나믹 프로그래밍은 **중복된 하위 문제들의 결과를 저장해뒀다가 풀이**해 나간다는 차이가 있다.

	* **'중복된'** 문제이지 않으면 다이나믹 프로그래밍으로 풀지 않습니다. 중복되지 않은 문제의 경우, 분할 정복 알고리즘으로 해결한다.

#### 1-1. 다이나믹 프로그래밍 방법론
1. **상향식 (Bottom-Up)** a.k.a. **Tabulation** : 더 작은 하위 문제부터 살펴본 다음, **작은 문제의 정답을 이용해 큰 문제의 정답을 푼다.** 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 한다. 데이터를 테이블 형태로 만들면서 문제를 풀이한다고 하여 타뷸레이션 방식이라고 부른다.
```
def fib(n):
	dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n + 1):
    	dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```
2. **하향식 (Top-Down)** a.k.a. **Memoization** : 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 푼다. **기존 재귀 풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적인 방식**으로, 메모이제이션 방식이라고 부른다.
```
def fib(n):
	if n <= 1:
    	return 1
        
    if dp[n]:
    	return dp[n]
    dp[n] = fib(n - 1) + fib(n - 2)
    return dp[n]
```

<hr/>

### 2. 그리디 알고리즘 (Greedy Algorithm)
##### 글로벌 최적을 찾기 위해 각 단계에서 로컬 최적의 선택을 하는 휴리스틱 문제 해결 알고리즘

* **눈 앞의 이익만을 좇는 알고리즘!**
    * 대부분의 경우에는 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장한다. -> 보통 최적화 문제를 대상으로 한다.
    * 그리디 알고리즘을 적용할 수 있는 문제 : 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure)인 문제들
        * 탐욕 선택 속성 : 앞의 선택이 이후 선택에 영향을 주지 않는 속성
        * 최적 부분 구조 : 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우
* 대표적인 적용 문제 : 다익스트라 알고리즘, 허프만 코딩 알고리즘, ID3 알고리즘
    * 다익스트라 알고리즘 : 최단 경로 문제를 풀이에 사용되며, 그래프에서 꼭짓점 간의 최단 경로를 찾는 알고리즘.
    * 허프만 코딩 알고리즘 : 자주 쓰이는 문자에 가장 작은 bit를 할당하고 덜 자주 쓰이는 문자일수록 큰 bit를 할당하여 이진트리를 사용한 압축 알고리즘
    * ID3 알고리즘 : 머신러닝에서 의사결정 트리 알고리즘으로 유명한 알고리즘
* 다이나믹 프로그래밍과의 비교 : 같은 최적 부분 구조 문제를 푼다는 점은 같으나, 서로 풀 수 있는 문제의 성격이 다르며 알고리즘의 접근 방식 또한 다르다.
    * 다이나믹 프로그래밍 : 하위 문제에 대한 최적의 솔루션을 찾은 다음, 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션에 대한 선택을 하는 알고리즘
    * 그리디 알고리즘 : 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태의 알고리즘
        * 서로 접근 방향이 반대이다!!

<hr/>

### 2. Manacher의 알고리즘 (Manacher's Algorithm)
##### 문자열 내에서 팰린드롬(회문)을 찾는 알고리즘. 시간 복잡도는 **O(n)**.

* 기본적으로 특정 문자를 중심으로 한 회문만 취급하기 때문에 abba와 같은 짝수 길이의 팰린드롬을 고려할 수 없지만, a#b#b#a와 같이 각 문자 사이에 특수한 관련없는 문자를 사이, 사이에 추가하여 계산하면 된다.

알고리즘
* 문자열 S에 대한 배열 A에 대해 진행한다.
1. i는 0부터 N - 1까지 진행된다.
2. j < i인 모든 j에 대해 r = max(j + A[j])이라 하고, 또한 그 j를 p라고 한다. 즉, r = p + A[p]
3. i와 r의 대소 관계에 따라 A[j]의 초기값이 결정된다.
    4. i > r이라면, A[i]의 초기값은 0이다.
    5. i <= r이라면, i는 p를 중심으로 한 회문에 속한다. 따라서 그 회문에서 i의 대칭점을 i'라 하면, i' = 2p - i. 그리고 A[i]의 초기값은 min(r - i, A[i'])이다.
6. A[i]의 초기값이 결정되고, S[i - A[i]]와 S[i + A[i]]가 같을 때까지 A[i]를 증가시킨다.

```
r = -1
p = -1
for i in range(n):
    if i <= r:
        A[i] = min(A[2 * p - i], r - i)
    else:
        A[i] = 0
    while S[i - A[i] - 1] == S[i + A[i] + 1]:
        A[i] = A[i] + 1
    if i + A[i] > r:
        r = i + A[i]
        p = i
```
- 이해는 되는데 쉽지 않다.. 나중에 다시 보고 적용할 수 있을 정도로 다시 공부해야겠다.

    
